#socket_buffer_size

配置客户端连接的缓存区长度。从1.8.8版本开始swoole底层对于缓存区控制的参数分离成`buffer_output_size`和`socket_buffer_size`两项配置。

参数`buffer_output_size`用于设置单次最大发送长度。`socket_buffer_size`用于设置客户端连接最大允许占用内存数量。

```shell
$server->set([
    'socket_buffer_size' => 128 * 1024 *1024, //必须为数字
])
```

* 单位为字节，如`128 * 1024 *1024`表示每个TCP客户端连接最大允许有`128M`待发送的数据
* 默认为`2M`字节

数据发送缓存区
-----
调整连接发送缓存区的大小。TCP通信有拥塞控制机制，服务器向客户端发送大量数据时，并不能立即发出。这时发送的数据会存放在服务器端的内存缓存区内。此参数可以调整内存缓存区的大小。

如果发送数据过多，客户端阻塞，数据占满缓存区后Server会报如下错误信息：
```
swFactoryProcess_finish: send failed, session#1 output buffer has been overflowed.
```
> 发送缓冲区塞满导致`send`失败，只会影响当前的客户端，其他客户端不受影响  
> 服务器有大量TCP连接时，最差的情况下将会占用`serv->max_connection * buffer_output_size`字节的内存

__尤其是外围通信的服务器程序，网络通信较慢，如果持续连续发送数据，缓冲区很快就会塞满。发送的数据会全部堆积在Server的内存里。因此此类应用应当从设计上考虑到网络的传输能力，先将消息存入磁盘，等客户端通知服务器已接受完毕后，再发送新的数据。__

如视频直播服务，A用户带宽是 100M，1秒内发送10M的数据是完全可以的。B用户带宽只有1M，如果1秒内发送10M的数据，B用户可能需要100秒才能接收完毕。这时数据会全部堆积在服务器内存中。

可以根据数据内容的类型，进行不同的处理。如果是可丢弃的内容，如视频直播等业务，网络差的情况下丢弃一些数据帧完全可以接受。如果内容是不可丢失的，如微信消息，可以先存储到服务器的磁盘中，按照100条消息为一组。当用户接受完这一组消息后，再从磁盘中取出下一组消息发送到客户端。